<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grayscale and Contrast Adjustment</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #drop-zone:hover {
            background-color: #c0c0c0;
            border: 2px dashed #cccccc;
        }
        .preview-img {
            max-height: 30%;
        }
        .container {
            display: flex;
            flex: 1;
        }
        .column {
            flex: 1;
            padding: 20px;
            margin-left: 20px;
            margin-right: 20px;
            margin-top: 0px;
            margin-bottom: 0px;
            border-radius: 10px;
            border: 2px solid #cccccc;
        }
        .left-column {
            max-width: 30%;
            background-color: #f0f0f0;
        }
        .right-column {
            background-color: #f0f0f0;
        }

    </style>
</head>
<body onload="docOnLoad()">
    <h1>Lithophane Corrector</h1>
    <div class="container">
        <div class="column left-column">
            <h3>Lithophane Thickness</h3>
            <table>
                <tr>
                    <td></td>
                    <td>Thickness (mm)</td>
                    <td></td> 
                    <td>Light Transmission</td>
                </tr>
                <tr>
                    <td>Max</td>
                    <td><input type="number" id="max-thickness" name="Max Thickness"/></td>
                    <td></td>
                    <td><input type="number" id="max-transmission" name="Max Transmission" disabled/></td>
                </tr>
                <tr>
                    <td>Min
                    <td><input type="number" id="min-thickness" name="Min Thickness"/></td>
                    <td></td>
                    <td><input type="number" id="min-transmission" name="Min Transmission" disabled/></td>
                </tr>
            </table>

            <h3>Lithophane Material</h3>
             <select id="material-select" name="Model Material" onchange="transmissionSelectOnChange()">
                <option value="pla_white">White PLA</option>
                <option value="custom">Custom</option>
            </select><p/>
            Sample Thickness (mm) <input type="number" id="transmission-thickness" name="Transmission Sample Thickness"/>
            <table id="transmission-table">
                <tr>
                    <td>Color</td>
                    <td>Relative Transmission</td>
                </tr>
                <tr>
                    <td>Red (595 nm)</td>
                    <td><input type="number" id="red-transmission" name="Red Transmission" onchange="transmissionInputOnChange()"/></td>
                </tr>
                <tr>
                    <td>Green (525 nm)</td>
                    <td><input type="number" id="green-transmission" name="Green Transmission" onchange="transmissionInputOnChange()"/></td>
                </tr>
                <tr>
                    <td>Blue (450 nm)</td>
                    <td><input type="number" id="blue-transmission" name="Blue Transmission" onchange="transmissionInputOnChange()"/></td>
                </tr>
            </table>
            <h3>Image Processing settings</h3>
            Maximize Contrast <input type="checkbox" id="maximize-contrast" name="Maximize Contrast" checked/><p/>
            Grayscale Algorithm <select id="grayscale-algorithm-select" name="Grayscale Algorithm" onchange="grayscaleSelectOnChange()">
                <option value="humaneye">Human eye adjusted</option>
                <option value="linear">Linear</option>
                <option value="custom">Custom</option>
            </select><p/>
            <table id="grayscale-table">
                <tr>
                    <td>Color</td>
                    <td>Relative Brightness</td>
                </tr>
                <tr>
                    <td>Red</td>
                    <td><input type="number" id="red-gray-value" name="Red Grayscale Value" onchange="grayscaleInputOnChange()"/></td>
                </tr>
                <tr>
                    <td>Green</td>
                    <td><input type="number" id="green-gray-value" name="Green Grayscale Value" onchange="grayscaleInputOnChange()"/></td>
                </tr>
                <tr>
                    <td>Blue</td>
                    <td><input type="number" id="blue-gray-value" name="Blue Grayscale Value" onchange="grayscaleInputOnChange()"/></td>
                </tr>
            </table>

            <h3>Lithophane Color settings</h3>
            Light Source <select id="lightsource-select" name="Illumination Source Color" onchange="lightsourceSelectOnChange()">
                <option value="sunlight">Sunlight (10000K)</option>
                <option value="7000k">Cool-white (7000K)</option>
                <option value="5700k">Day-white (5700K)</option>
                <option value="4000k">Natural-white (4000K)</option>
                <option value="2700k">Warm-white (2700K)</option>
                <option value="custom">Custom</option>
            </select><p/>
            <table id="light-source-table">
                <tr>
                    <td>Color</td>
                    <td>Relative Light Output</td>
                </tr>
                <tr>
                    <td>Red</td>
                    <td><input type="number" id="red-light" name="Light Red Output" onchange="lightsourceInputOnChange()"/></td>
                </tr>
                <tr>
                    <td>Green</td>
                    <td><input type="number" id="green-light" name="Light Green Output" onchange="lightsourceInputOnChange()"/></td>
                </tr>
                <tr>
                    <td>Blue</td>
                    <td><input type="number" id="blue-light" name="Light Blue Output" onchange="lightsourceInputOnChange()"/></td>
                </tr>
            </table>

            <h3>Human-eye Adjustment</h3>
            Color Sensitivity <select id="human-eye-select" name="Human-eye Adjustment" onchange="eyesensSelectOnChange()">
                <option value="standard">Standard</option>
                <option value="custom">Custom</option>
            </select><p/>
            <table id="eye-sens-table">
                <tr>
                    <td>Color</td>
                    <td>Relative Sensitivity</td>
                </tr>
                <tr>
                    <td>Red</td>
                    <td><input type="number" id="red-eye-sens" name="Red Eye Sensitivity" onchange="eyesenseInputOnChange()"/></td>
                </tr>
                <tr>
                    <td>Green</td>
                    <td><input type="number" id="green-eye-sens" name="Green Eye Sensitivity" onchange="eyesenseInputOnChange()"/></td>
                </tr>
                <tr>
                    <td>Blue</td>
                    <td><input type="number" id="blue-eye-sens" name="Blue Eye Sensitivity" onchange="eyesenseInputOnChange()"/></td>
                </tr>
            </table>
        </div>
        <div class="column right-column" id="drop-zone">
            <canvas id="canvas" style="display:none"></canvas>
            <img id="orig-img" class="preview-img" src=""/><p/>
            <input type="button" value="Generate Grayscale", onclick="computeGrayscale()"></input>
            <img id="gray-img" class="preview-img" src=""/><p/>
            <input type="button" value="Generate Heightmap", onclick="computeHeightmap()"></input>
            <img id="output-img" class="preview-img" src=""/><p/>
        </div>
    </div>

    <script>
        //----------Easy access to DOM elements
        const dropZone = document.getElementById('drop-zone');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const origImg = document.getElementById('orig-img');
        const grayImg = document.getElementById('gray-img');
        const outputImg = document.getElementById('output-img');

        //Lithophane dimensional limitations
        const maxThicknessInput = document.getElementById("max-thickness");
        const minThicknessInput = document.getElementById("min-thickness");
        const maxTransmissionInput = document.getElementById("max-transmission");
        const minTransmissionInput = document.getElementById("min-transmission");
        let maxThickness = 0;
        let minThickness = 0;
        let maxTransmission = 0;
        let minTransmission = 0;

        //RGB-Grayscale parameters
        const maximizeContrastCheckbox = document.getElementById("maximize-contrast");
        const grayscaleAlgoSelect = document.getElementById("grayscale-algorithm-select");
        const redGrayValueInput = document.getElementById("red-gray-value");
        const greenGrayValueInput = document.getElementById("green-gray-value");
        const blueGrayValueInput = document.getElementById("blue-gray-value");
        let redGrayValue = 0;
        let greenGrayValue = 0;
        let blueGrayValue = 0;
        let c_redGrayValue = 0;
        let c_greenGrayValue = 0;
        let c_blueGrayValue = 0;
        let i_redGrayValue = 0;
        let i_greenGrayValue = 0;
        let i_blueGrayValue = 0;

        //Material characteristics
        const materialSelect = document.getElementById("material-select");
        let previousMaterial = null;
        let material = null;
        const redTransmissionInput = document.getElementById("red-transmission");
        const greenTransmissionInput = document.getElementById("green-transmission");
        const blueTransmissionInput = document.getElementById("blue-transmission");
        const transmissionThicknessInput = document.getElementById("transmission-thickness");
        let transmissionThickness = 0;
        let redTransmission = 0;
        let greenTransmission = 0;
        let blueTransmission = 0;
        let c_redTransmission = 0;
        let c_greenTransmission = 0;
        let c_blueTransmission = 0;
        let i_redAbsorbance = 0;
        let i_greenAbsorbance = 0;
        let i_blueAbsorbance = 0;

        //Illumination source parameters
        const lightSourceSelect = document.getElementById('lightsource-select');
        let previousLightSource = null;
        let lightSource = null;
        const redLightInput = document.getElementById("red-light");
        const greenLightInput = document.getElementById("green-light");
        const blueLightInput = document.getElementById("blue-light");
        let redLight = 0;
        let greenLight = 0;
        let blueLight = 0;
        let c_redLight = 0;
        let c_greenLight = 0;
        let c_blueLight = 0;
        let i_redLight = 0;
        let i_greenLight = 0;
        let i_blueLight = 0;

        //Apparent brightness after transmission through the lithophane
        const eyeSensSelect = document.getElementById('human-eye-select');
        const eyeSensTable = document.getElementById('eye-sens-table');
        const redEyeSensInput = document.getElementById("red-eye-sens");
        const greenEyeSensInput = document.getElementById("green-eye-sens");
        const blueEyeSensInput = document.getElementById("blue-eye-sens");
        let eyeSens = null;
        let redEyeSens = 0;
        let greenEyeSens = 0;
        let blueEyeSens = 0;
        let c_redEyeSens = 0;
        let c_greenEyeSens = 0;
        let c_blueEyeSens = 0;
        let i_redEyeSens = 0;
        let i_greenEyeSens = 0;
        let i_blueEyeSens = 0;
        let i_redApparentFlux = 0;
        let i_greenApparentFlux = 0;
        let i_blueApparentFlux = 0;

        //For quickly finding correct thicknesses, a lookup table will be computed
        let grayThicknessMap =[];
        let grayThicknessMapValid = false;

        //Intermediate calculations
        let rgbImage=null;
        let rgbArray=[];
        let rgbDataValid=false;

        let grayscaleImage = null;
        let grayscaleArray=[];
        let grayscaleDataValid = false;

        let thicknessArray = [];
        let thicknessDataValid = false;

        let heightImage = null;
        let heightArray = []
        let heightDataValid = false;

        class GrayscaleControl {
            constructor() {
                this.grayscaleArray = [];
                this.grayscaleImage = null;
                this.grayscaleWidth = 0;
                this.grayscaleHeight = 0;
                //Load items from browser storage
                this.maximizeContrast = localStorage.getItem("grayscaleControl_maximizeContrast") || true;
                this.customRedValue = localStorage.getItem("grayscaleControl_customRedValue") || 0.299;
                this.customGreenValue = localStorage.getItem("grayscaleControl_customGreenValue") || 0.587;
                this.customBlueValue = localStorage.getItem("grayscaleControl_customBlueValue") || 0.114;
                this.onChange(); //Call before loading current algo from storage
                this.algo = localStorage.getItem("grayscaleControl_Algo") || 'humaneye';
            }

            saveValues() {
                localStorage.setItem("grayscaleControl_maximizeContrast", this.maximizeContrast);
                localStorage.setItem("grayscaleControl_Algo", this.algo);
                localStorage.setItem("grayscaleControl_customRedValue", this.customRedValue);
                localStorage.setItem("grayscaleControl_customGreenValue", this.customGreenValue);
                localStorage.setItem("grayscaleControl_customBlueValue", this.customBlueValue);
            }

            onChange() {
                //Check if previous algo was custom and save values
                if(this.algo == "custom") {
                    this.customRedValue = document.getElementById("red-gray-value").valueAsNumber;
                    this.customGreenValue = document.getElementById("green-gray-value").valueAsNumber;
                    this.customBlueValue = document.getElementById("blue-gray-value").valueAsNumber;
                }
                //Get the algo we are changing to
                const nextAlgo = document.getElementById("grayscale-algorithm-select").value;
                switch(nextAlgo) {
                    case "humaneye":
                        this.redValue = 0.299;
                        this.greenValue = 0.587;
                        this.blueValue = 0.114;
                        break;

                    case "linear":
                        this.redValue = 1.0;
                        this.greenValue = 1.0;
                        this.blueValue = 1.0;
                        break;

                    case "custom":
                        this.redValue = this.customRedValue;
                        this.greenValue = this.customGreenValue;
                        this.blueValue = this.customBlueValue;
                        break;
                }
                //If required, change the values shown in the UI
                if(this.algo != nextAlgo) {
                    this.setUIValues();
                }
                //Set current algo to the ui input value
                this.algo = nextAlgo;
            }

            inputChange() {

            }

            

            updateUIValues() {
                this.maximizeContrast = document.getElementById("maximize-contrast").value;
                //Store the input values if we were on custom algo
                const nextAlgo = document.getElementById("grayscale-algorithm-select").value;
                
                
                

                this.algo = ;
                this.redValue = document.getElementById("red-gray-value").valueAsNumber;
                this.greenValue = document.getElementById("green-gray-value").valueAsNumber;
                this.blueValue = document.getElementById("blue-gray-value").valueAsNumber;
            }

            setUIValues() {

            }

            normalizeValues() {
                

            }

            convertRGBToGrayscale(rgbImage) {
                //Compute normalized grayscale values
                const totalValue = this.redValue + this.greenValue + this.blueValue;
                const redScale = this.redValue / totalValue;
                const greenScale = this.greenValue / totalValue;
                const blueScale = this.blueValue / totalValue;
                //Make new image data
                this.grayscaleWidth = rgbImage.width;
                this.grayscaleHeight = rgbImage.height;
                const rgbArray = rgbImage.data;
                //Create arrays
                this.grayscaleArray = new Array(); //R,G,B
                let grayscaleImageArray = new Uint8ClampedArray(); //R,G,B,Alpha
                //Compute grayscale array
                let minGray = 255;
                let maxGray = 0;
                for (let i = 0; i < rgbArray.length; i += 4) {
                    let gray = redScale * rgbArray[i] + 
                                greenScale * rgbArray[i + 1] + 
                                blueScale * rgbArray[i + 2];
                    if(gray < minGray) minGray = gray;
                    if(gray > maxGray) maxGray = gray;
                    this.grayscaleArray.push(gray);
                }

                //Maximize contrast if required
                let scale = 0;
                if(this.maximizeContrast) {
                    scale = 255 / (maxGray - minGray);
                }
                else {
                    scale = 1;
                }
                //Compute the grayscale image array and rescale the grayscale array
                for (let i = 0; i < this.grayscaleArray.length; i += 1) {
                    const gray = this.grayscaleArray[i];
                    const scaledGray = (gray - minGray) * scale;
                    const uint8ScaleGray = Math.floor(scaledGray);
                    grayscaleArray[i] = scaledGray;
                    grayscaleImageArray.push(uint8ScaleGray);
                    grayscaleImageArray.push(uint8ScaleGray);
                    grayscaleImageArray.push(uint8ScaleGray);
                    grayscaleImageArray.push(255);
                }
                //Create the image
                this.grayscaleImage = new Image();
                this.grayscaleImage.data = new ImageData(grayscaleImageArray,
                                                        this.grayscaleWidth, 
                                                        this.grayscaleHeight);
                return this.grayscaleImage;
                //ctx.putImageData(grayscaleImage.data, 0, 0);
                //grayImg.src = canvas.toDataURL();
            }
        }

        function docOnLoad() {
            loadStorageValues();
            computeSelectValues();
            setDisabledInputs();
            setUIValues();
            setListeners();
        }

        function setListeners() {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        loadImage(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            });

            grayscaleAlgoSelect.addEventListener('change', onSelectChange);
            materialSelect.addEventListener('change', onSelectChange);
            lightSourceSelect.addEventListener('change', onSelectChange);
            eyeSensSelect.addEventListener('change', onSelectChange);
        }

        function onSelectChange() {
            getCustomValues();
            getSelectValues();
            computeSelectValues();
            getOtherUIValues();
            setDisabledInputs();
            setUIValues();
        }

        function loadStorageValues() {
            maxThickness = localStorage.getItem("maxThickness") || 10;
            minThickness = localStorage.getItem("minThickness") || 0.6;
            maxTransmission = localStorage.getItem("maxTransmission") || 0.8;
            minTransmission = localStorage.getItem("minTransmission") || 0.15;

            

            material = localStorage.getItem("material") || "pla_white";
            c_redTransmission = localStorage.getItem("c_redTransmission") || 0.901;
            c_greenTransmission = localStorage.getItem("c_greenTransmission") || 0.707;
            c_blueTransmission = localStorage.getItem("c_blueTransmission") || 0.484;
            transmissionThickness = localStorage.getItem("transmissionThickness") || 2.0;

            lightSource = localStorage.getItem("lightSource") || "sunlight";
            c_redLight = localStorage.getItem("c_redLight") || 300;
            c_greenLight = localStorage.getItem("c_greenLight") || 300;
            c_blueLight = localStorage.getItem("c_blueLight") || 400;

            eyeSens = localStorage.getItem("EyeSens") || "standard";
            c_redEyeSens = localStorage.getItem("c_redEyeSens") || 0.299;
            c_greenEyeSens = localStorage.getItem("c_greenEyeSens") || 0.587;
            c_blueEyeSens = localStorage.getItem("c_blueEyeSens") || 0.114;
        }

        function saveStorageValues() {
            localStorage.setItem("maxThickness", maxThickness);
            localStorage.setItem("minThickness", minThickness);
            localStorage.setItem("maxTransmission", maxTransmission);
            localStorage.setItem("minTransmission", minTransmission);
            
            localStorage.setItem("material", material);
            localStorage.setItem("c_redTransmission", c_redTransmission);
            localStorage.setItem("c_greenTransmission", c_greenTransmission);
            localStorage.setItem("c_blueTransmission", c_blueTransmission);
            localStorage.setItem("lightSource", lightSource);
            localStorage.setItem("c_redLight", c_redLight);
            localStorage.setItem("c_greenLight", c_greenLight);
            localStorage.setItem("c_blueLight", c_blueLight);
            localStorage.setItem("eyeSens", eyeSens);
            localStorage.setItem("c_redEyeSens", c_redEyeSens);
            localStorage.setItem("c_greenEyeSens", c_greenEyeSens);
            localStorage.setItem("c_blueEyeSens", c_blueEyeSens);
        }

        function setUIValues() {
            maxThicknessInput.value = maxThickness;
            minThicknessInput.value = minThickness;
            maxTransmissionInput.value = maxTransmission;
            minTransmissionInput.value = minTransmission;

            maximizeContrastCheckbox.checked = maximizeContrast;
            grayscaleAlgoSelect.value = grayscaleAlgo;
            redGrayValueInput.value = redGrayValue;
            greenGrayValueInput.value = greenGrayValue;
            blueGrayValueInput.value = blueGrayValue;

            materialSelect.value = material;
            redTransmissionInput.value = redTransmission;
            greenTransmissionInput.value = greenTransmission;
            blueTransmissionInput.value = blueTransmission;
            transmissionThicknessInput.value = transmissionThickness;

            lightSourceSelect.value = lightSource;
            redLightInput.value = redLight;
            greenLightInput.value = greenLight;
            blueLightInput.value = blueLight;

            eyeSensSelect.value = eyeSens;
            redEyeSensInput.value = redEyeSens;
            greenEyeSensInput.value = greenEyeSens;
            blueEyeSensInput.value = blueEyeSens;
        }

        function getOtherUIValues() {
            maxThickness = maxThicknessInput.valueAsNumber;
            minThickness = minThicknessInput.valueAsNumber;
            maxTransmission = maxTransmissionInput.valueAsNumber;
            minTransmission = minTransmissionInput.valueAsNumber;
            maximizeContrast = maximizeContrastCheckbox.checked;
            transmissionThickness = transmissionThicknessInput.valueAsNumber;
        }

        function setDisabledInputs() {
            if(grayscaleAlgo != "custom") {
                    redGrayValueInput.disabled = true;
                    greenGrayValueInput.disabled = true;
                    blueGrayValueInput.disabled = true;
            }
            else {
                redGrayValueInput.disabled = false;
                greenGrayValueInput.disabled = false;
                blueGrayValueInput.disabled = false;
            }

            if(material != "custom") {
                    redTransmissionInput.disabled = true;
                    greenTransmissionInput.disabled = true;
                    blueTransmissionInput.disabled = true;
            }
            else {
                redTransmissionInput.disabled = false;
                greenTransmissionInput.disabled = false;
                blueTransmissionInput.disabled = false;
            }

            if(lightSource != "custom") {
                    redLightInput.disabled = true;
                    greenLightInput.disabled = true;
                    blueLightInput.disabled = true;
            }
            else {
                redLightInput.disabled = false;
                greenLightInput.disabled = false;
                blueLightInput.disabled = false;
            }

            if(eyeSens != "custom") {
                    redEyeSensInput.disabled = true;
                    greenEyeSensInput.disabled = true;
                    blueEyeSensInput.disabled = true;
            }
            else {
                redEyeSensInput.disabled = false;
                greenEyeSensInput.disabled = false;
                blueEyeSensInput.disabled = false;
            }
        }

        function getCustomValues() {
            //First save existing input values if the previous
            //select value was custom
            if(grayscaleAlgo == "custom") {
                    c_redGrayValue = redGrayValueInput.valueAsNumber;
                    c_greenGrayValue = greenGrayValueInput.valueAsNumber;
                    c_blueGrayValue = blueGrayValueInput.valueAsNumber;
            }
            if(material == "custom") {
                    c_redTransmission = redTransmissionInput.valueAsNumber;
                    c_greenTransmission = greenTransmissionInput.valueAsNumber;
                    c_blueTransmission = blueTransmissionInput.valueAsNumber;
            }
            if(lightSource == "custom") {
                    c_redLight = redLightInput.valueAsNumber;
                    c_greenLight = greenLightInput.valueAsNumber;
                    c_blueLight = blueLightInput.valueAsNumber;
            }
            if(eyeSens == "custom") {
                    c_redEyeSens = redEyeSensInput.valueAsNumber;
                    c_greenEyeSens = greenEyeSensInput.valueAsNumber;
                    c_blueEyeSens = blueEyeSensInput.valueAsNumber;
            }
        }

        function getSelectValues() {
            //Get current select box values
            grayscaleAlgo = grayscaleAlgoSelect.value;
            material = materialSelect.value;
            lightSource = lightSourceSelect.value;
            eyeSens = eyeSensSelect.value;
        }

        function computeSelectValues() {
            switch(grayscaleAlgo) {
                case "humaneye":
                    redGrayValue = 0.299;
                    greenGrayValue = 0.587;
                    blueGrayValue = 0.114;
                    break;

                case "linear":
                    redGrayValue = 1.0;
                    greenGrayValue = 1.0;
                    blueGrayValue = 1.0;
                    break;

                case "custom":
                    redGrayValue = c_redGrayValue;
                    greenGrayValue = c_greenGrayValue;
                    blueGrayValue = c_blueGrayValue;
                    break;
            }

            switch(material) {
                case "pla_white":
                    redTransmission = 0.901 ;
                    greenTransmission =  0.707;
                    blueTransmission =  0.484;
                    break;

                case "custom":
                    redTransmission = c_redTransmission ;
                    greenTransmission = c_greenTransmission;
                    blueTransmission = c_blueTransmission;
                    break;
            }

            switch(lightSource) {
                case "sunlight":
                    redLight = 300;
                    greenLight = 300;
                    blueLight = 400;
                    break;

                case "7000k":
                    redLight = 100;
                    greenLight = 100;
                    blueLight = 100;
                    break;

                case "5700k":
                    redLight = 100;
                    greenLight = 100;
                    blueLight = 100;
                    break;

                case "4000k":
                    redLight = 100;
                    greenLight = 100;
                    blueLight = 100;
                    break;

                case "2700k":
                    redLight = 100;
                    greenLight = 100;
                    blueLight = 100;
                    break;

                case "custom":
                    redLight = c_redLight;
                    greenLight = c_greenLight;
                    blueLight = c_blueLight;
                    break;
            }

            switch(eyeSens) {
                case "standard":
                    redEyeSens = 0.299;
                    greenEyeSens = 0.587;
                    blueEyeSens = 0.114;
                    break;

                case "custom":
                    redEyeSens = c_redEyeSens;
                    greenEyeSens = c_greenEyeSens;
                    blueEyeSens = c_blueEyeSens;
                    break;
            }
        }

        function loadImage(imgSrc) {
            const img = new Image();
            img.src = imgSrc;
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                rgbImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                rgbArray = rgbImage.data;
                origImg.src = canvas.toDataURL();
                rgbDataValid = true;
                grayscaleDataValid = false;
            };
        }

        function computeGrayscale() {
            saveStorageValues();
            getCustomValues();
            getSelectValues();
            computeSelectValues();
            getOtherUIValues();
            computeConstants();
            makeGrayscaleArray();
            
        }

        //Calculate the heightmap
        function computeHeightmap() {
            saveStorageValues();
            getCustomValues();
            getSelectValues();
            computeSelectValues();
            getOtherUIValues();
            computeConstants();
            calculateGrayThicknessLookupArray();
            calculateThicknessArray();
            calculateAdjustedGrayscale();
            heightImage = new Image();
            heightImage.data = new ImageData(new Uint8ClampedArray(heightArray),
                                                rgbImage.width, rgbImage.height);
            ctx.putImageData(heightImage, 0, 0);
            // Display the resulting image
            outputImg.src = canvas.toDataURL();
        }

        function computeConstants() {
            //Compute the rgb->grayscale constants
            let totalGrayValue = redGrayValue + greenGrayValue + blueGrayValue;
            i_redGrayValue = redGrayValue/totalGrayValue;
            i_greenGrayValue = greenGrayValue/totalGrayValue;
            i_blueGrayValue = blueGrayValue/totalGrayValue;
            //Normalize and compute the spectral absorbances
            let totalTransmission = redTransmission + greenTransmission + blueTransmission;
            i_redAbsorbance = Math.log(redTransmission/totalTransmission)/transmissionThickness;
            i_greenAbsorbance = Math.log(greenTransmission/totalTransmission)/transmissionThickness;
            i_blueAbsorbance = Math.log(blueTransmission/totalTransmission)/transmissionThickness;
            //Normalize and compute the spectral flux of the lightsource
            let totalLight = redLight + greenLight + blueLight;
            i_redLight = redLight/totalLight;
            i_greenLight = greenLight/totalLight;
            i_blueLight = blueLight/totalLight;
            //Normalize and compute the spectra eye sensitivity
            let totalEyeSens = redEyeSens + greenEyeSens + blueEyeSens;
            i_redEyeSens = redEyeSens/totalEyeSens;
            i_greenEyeSens = greenEyeSens/totalEyeSens;
            i_blueEyeSens = blueEyeSens/totalEyeSens;
            //Use the lightsource flux and eye sensitivity to get the apparent spectral flux
            let totalApparentFlux = (i_redLight*i_redEyeSens) + 
                                    (i_greenLight*i_greenEyeSens) +
                                    (i_blueLight*i_blueEyeSens);
            i_redApparentFlux = (i_redLight * i_redEyeSens) / totalApparentFlux;
            i_greenApparentFlux = (i_greenLight * i_greenEyeSens) / totalApparentFlux;
            i_blueApparentFlux = (i_blueLight * i_blueEyeSens) / totalApparentFlux;
        }

        //Calculate the grayscale image
        function makeGrayscaleArray() {
            
        }


        function calculateGrayThicknessLookupArray() {
            //Produce a lookup array of thicknesses where the index into the array
            //is the gray value (0-255) and the value at that index is the thickness
            grayThicknessMap = [];
            let thickness_guess = 0.5;
            let transmission_per_bit = (maxTransmission - minTransmission)/255;
            for(let gray=0; gray<256; gray += 1) {
                const transmission = (gray*transmission_per_bit)+minTransmission;
                const thickness = findThicknessForTransmission(transmission, thickness_guess)
                thickness_guess = thickness;
                grayThicknessMap.push(thickness)
            }
        }

        function calculateThicknessArray() {
            thicknessArray=[]       
            for (let i = 0; i < grayscaleArray.length; i += 4) {
                const l = grayThicknessMap[Math.floor(grayscaleArray[i])];
                thicknessArray.push(l);
            }
        }

        function calculateAdjustedGrayscale() {
            //Create a new greyscale image where white = minthickness and
            //black = maxthickness
            thicknessMin = 150;
            thicknessMax = 0;
            //Find min and max thickness values
            for (let i = 0; i < thicknessArray.length; i += 1) {
                const thickness = thicknessArray[i];
                if (thickness < thicknessMin) thicknessMin = thickness;
                if (thickness > thicknessMax) thicknessMax = thickness;
            }

            const thicknessRange = thicknessMax - thicknessMin;
            heightArray = [];
            for (let i = 0; i < thicknessArray.length; i += 1) {
                const grayFrac = 1 - ((thicknessArray[i]-thicknessMin)/thicknessRange);
                const gray = Math.floor(255*grayFrac);
                const pixelIndex=4*i;
                heightArray.push(gray);
                heightArray.push(gray);
                heightArray.push(gray);
                heightArray.push(255);
            }
        }

        function beerLambertMultiWavelength(length) {
            //Beer-lambert law: It = I0 * e^-a*l
            //For multiple wavelengths (r,g,b) total light=
            //Itrgb = (Ir*e^-ar*l) + (Ig*e^-ag*l) + (Ib*e^-ab*l)
            const Itrgb = (i_redApparentFlux * Math.exp(absorbanceRed*length))+
                        (i_greenApparentFlux * Math.exp(absorbanceGreen*length))+
                        (i_blueApparentFlux * Math.exp(absorbanceBlue*length));
            return Itrgb;
        }

        function derivBeerLambertMultiWavelength(length) {
            //Deriviative of beer-lambert law for multiple absorbance/wavelengths
            const dItrgb = (absorbanceRed * i_redApparentFlux * Math.exp(absorbanceRed*length))+
                        (absorbanceGreen * i_greenApparentFlux * Math.exp(absorbanceGreen*length))+
                        (absorbanceBlue * i_blueApparentFlux * Math.exp(absorbanceBlue*length));
            return dItrgb;
        }

        function findThicknessForTransmission(targetgray, initialThickness, tolerance = 0.0001, maxIterations = 100) {
            //Uses Newton-Raphson formula to find a thickness for a given targetGray value
            let x = initialThickness;
            for (let i = 0; i < maxIterations; i++) {
                const y = beerLambertMultiWavelength(x);
                const error = y - targetgray;
                if (Math.abs(error) < tolerance) {
                    return x;
                }
                const derivative = derivBeerLambertMultiWavelength(x);
                if (derivative === 0) {
                    console.error("Derivative is zero. No solution found.");
                    return null;
                }
                x = x - error / derivative; 
            }
            console.error("Max iterations reached without convergence.");
            return null; // Return null if no solution is found within the iteration limit
        }

    </script>
</body>
</html>
