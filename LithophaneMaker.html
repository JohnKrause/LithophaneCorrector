<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grayscale and Contrast Adjustment</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            font-size: 16px;
            padding: 5px;
            margin: 0px;
        }
        h1 {
            margin: 0px;
        }
        h2 {
            margin: 0px;
        }
        h3 {
            margin:0px;
        }
        table {
            margin: 0px;
            padding: 0px;
            border: 0px;
        }
        .container {
            display: flex;
            flex: 1;
        }
        .column {
            flex: 1;
            padding: 10px;
            margin: 0px;
            border-radius: 10px;
            border: 2px solid #cccccc;
        }
        .left-column {
            max-width: 30%;
            background-color: #f0f0f0;
        }
        .right-column {
            background-color: #f0f0f0;
        }
        .settings-table {
            width: 100%;
        }
        .settings-table td {
            width:50%;
        }
        .settings-table input {
            width: 100%;
        }
        .preview-img {
            width: 400px;
        }
        #drop-zone:hover {
            background-color: #c0c0c0;
            border: 2px dashed #cccccc;
        }
        

    </style>
</head>
<body onload="docOnLoad()">
    <h1>Lithophane Corrector</h1>
    <div class="container">
        <div class="column left-column">
            <table>
                <tr>
                    <td colspan="4"><h3>Lithophane Thickness:</h3></td>
                </tr>
                <tr>
                    <td></td>
                    <td>Thickness (mm)</td>
                    <td></td> 
                    <td>Light Transmission</td>
                </tr>
                <tr>
                    <td>Max</td>
                    <td><input type="number" step=0.01 id="max-thickness" name="Max Thickness"/></td>
                    <td></td>
                    <td><input type="number" step=0.01 id="max-transmission" name="Max Transmission" disabled/></td>
                </tr>
                <tr>
                    <td>Min
                    <td><input type="text" id="min-thickness" name="Min Thickness"/></td>
                    <td></td>
                    <td><input type="text" id="min-transmission" name="Min Transmission" disabled/></td>
                </tr>
            </table>
            
            <table class="settings-table">
                <tr>
                    <td><h3>Lithophane Material:</h3></td>
                    <td><select id="material-select" name="Model Material">
                        <option value="pla_white">White PLA</option>
                        <option value="custom">Custom</option>
                    </select></td>
                </tr>
                <tr>
                    <td>Sample Thickness (mm)</td>
                    <td><input type="number" step=0.01 id="transmission-thickness" name="Transmission Sample Thickness"/></td>
                <tr>
                    <td>Color</td>
                    <td>Relative Transmission</td>
                </tr>
                <tr>
                    <td>Red (595 nm)</td>
                    <td><input type="text" id="red-transmission" name="Red Transmission"/></td>
                </tr>
                <tr>
                    <td>Green (525 nm)</td>
                    <td><input type="text" id="green-transmission" name="Green Transmission"/></td>
                </tr>
                <tr>
                    <td>Blue (450 nm)</td>
                    <td><input type="text" id="blue-transmission" name="Blue Transmission"/></td>
                </tr>
            </table>

            <table class="settings-table">
                <tr>
                    <td><h3>Grayscale Algorithm:</h3></td>
                    <td><select id="grayscale-algorithm-select" name="Grayscale Algorithm">
                        <option value="humaneye">Human eye adjusted</option>
                        <option value="linear">Linear</option>
                        <option value="custom">Custom</option>
                        </select></td>
                </tr>
                <tr>
                    <td>Maximize Contrast</td>
                    <td><input type="checkbox" id="maximize-contrast" name="Maximize Contrast" checked/></td>
                </tr>
                <tr>
                    <td>Color</td>
                    <td>Relative Brightness</td>
                </tr>
                <tr>
                    <td>Red</td>
                    <td><input type="text" id="red-gray-value" name="Red Grayscale Value"/></td>
                </tr>
                <tr>
                    <td>Green</td>
                    <td><input type="text" id="green-gray-value" name="Green Grayscale Value"/></td>
                </tr>
                <tr>
                    <td>Blue</td>
                    <td><input type="text" id="blue-gray-value" name="Blue Grayscale Value"/></td>
                </tr>
            </table>

            <table class="settings-table">
                <tr>
                    <td><h3>Light Source:</h3></td>
                    <td><select id="lightsource-select" name="Illumination Source Color">
                        <option value="sunlight">Sunlight (10000K)</option>
                        <option value="7000k">Cool-white (7000K)</option>
                        <option value="5700k">Day-white (5700K)</option>
                        <option value="4000k">Natural-white (4000K)</option>
                        <option value="2700k">Warm-white (2700K)</option>
                        <option value="custom">Custom</option>
                    </select></td>
                </tr>
                <tr>
                    <td>Color</td>
                    <td>Relative Light Output</td>
                </tr>
                <tr>
                    <td>Red</td>
                    <td><input type="text" id="red-light" name="Light Red Output"/></td>
                </tr>
                <tr>
                    <td>Green</td>
                    <td><input type="text" id="green-light" name="Light Green Output"/></td>
                </tr>
                <tr>
                    <td>Blue</td>
                    <td><input type="text" id="blue-light" name="Light Blue Output"/></td>
                </tr>
            </table>

            <table class="settings-table">
                <tr>
                    <td><h3>Light Sensitivity:</h3></td>  
                    <td><select id="human-eye-select" name="Human-eye Adjustment">
                        <option value="standard">Standard</option>
                        <option value="custom">Custom</option>
                    </select></td>
                </tr>
                <tr>
                    <td>Color</td>
                    <td>Relative Sensitivity</td>
                </tr>
                <tr>
                    <td>Red</td>
                    <td><input type="text" id="red-eye-sens" name="Red Eye Sensitivity"/></td>
                </tr>
                <tr>
                    <td>Green</td>
                    <td><input type="text" id="green-eye-sens" name="Green Eye Sensitivity"/></td>
                </tr>
                <tr>
                    <td>Blue</td>
                    <td><input type="text" id="blue-eye-sens" name="Blue Eye Sensitivity"/></td>
                </tr>
            </table>
        </div>

        <div class="column right-column" id="drop-zone">
            <table>
                <tr><td><h3>Original Image</h3></td></tr>
                <tr><td><img id="orig-img" class="preview-img" src=""/></td></tr>
                <tr><td><h3>Grayscale Image</h3></td></tr>
                <tr><td><input type="button" value="Generate Grayscale", onclick="computeGrayscale()"></input></td></tr>
                <tr><td><img id="gray-img" class="preview-img" src=""/><p/></td></tr>
                <tr><td><h3>Grayscale Heightmap</h3></td></tr>
                <tr><td><input type="button" value="Generate Heightmap", onclick="computeHeightmap()"></input></td></tr>
                <tr><td><img id="output-img" class="preview-img" src=""/><p/></td></tr>
            </table>
        </div>

    </div>
    <canvas id="canvas" style="display:none"></canvas>

    <script>
        //----------Easy access to DOM elements
        const dropZone = document.getElementById('drop-zone');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const origImg = document.getElementById('orig-img');
        const grayImg = document.getElementById('gray-img');
        const outputImg = document.getElementById('output-img');
        const maxThicknessInput = document.getElementById("max-thickness");
        const minThicknessInput = document.getElementById("min-thickness");
        const maxTransmissionInput = document.getElementById("max-transmission");
        const minTransmissionInput = document.getElementById("min-transmission");
        let maxThickness = 0;
        let minThickness = 0;
        let maxTransmission = 0;
        let minTransmission = 0;

        const maximizeContrastCheckbox = document.getElementById("maximize-contrast");
        const grayscaleAlgoSelect = document.getElementById("grayscale-algorithm-select");
        let previousGrayscaleAlgo = null;
        const redGrayValueInput = document.getElementById("red-gray-value");
        const greenGrayValueInput = document.getElementById("green-gray-value");
        const blueGrayValueInput = document.getElementById("blue-gray-value");
        let maximizeContrast = 0;
        let redGrayValue = 0;
        let greenGrayValue = 0;
        let blueGrayValue = 0;
        let c_redGrayValue = 0;
        let c_greenGrayValue = 0;
        let c_blueGrayValue = 0;
        let i_redGrayValue = 0;
        let i_greenGrayValue = 0;
        let i_blueGrayValue = 0;

        const materialSelect = document.getElementById("material-select");
        let previousMaterial = null;
        const transmissionThicknessInput = document.getElementById("transmission-thickness");
        const redTransmissionInput = document.getElementById("red-transmission");
        const greenTransmissionInput = document.getElementById("green-transmission");
        const blueTransmissionInput = document.getElementById("blue-transmission");
        let transmissionThickness = 0;
        let redTransmission = 0;
        let greenTransmission = 0;
        let blueTransmission = 0;
        let c_redTransmission = 0;
        let c_greenTransmission = 0;
        let c_blueTransmission = 0;
        let i_redAbsorbance = 0;
        let i_greenAbsorbance = 0;
        let i_blueAbsorbance = 0;

        const lightSourceSelect = document.getElementById('lightsource-select');
        let previousLightSource = null;
        const redLightInput = document.getElementById("red-light");
        const greenLightInput = document.getElementById("green-light");
        const blueLightInput = document.getElementById("blue-light");
        let redLight = 0;
        let greenLight = 0;
        let blueLight = 0;
        let c_redLight = 0;
        let c_greenLight = 0;
        let c_blueLight = 0;
        let i_redLight = 0;
        let i_greenLight = 0;
        let i_blueLight = 0;

        const eyeSensSelect = document.getElementById('human-eye-select');
        let previousEyeSens = null;
        const redEyeSensInput = document.getElementById("red-eye-sens");
        const greenEyeSensInput = document.getElementById("green-eye-sens");
        const blueEyeSensInput = document.getElementById("blue-eye-sens");
        let redEyeSens = 0;
        let greenEyeSens = 0;
        let blueEyeSens = 0;
        let c_redEyeSens = 0;
        let c_greenEyeSens = 0;
        let c_blueEyeSens = 0;
        let i_redEyeSens = 0;
        let i_greenEyeSens = 0;
        let i_blueEyeSens = 0;

        let i_redApparentFlux = 0;
        let i_greenApparentFlux = 0;
        let i_blueApparentFlux = 0;

        //For quickly finding correct thicknesses, a lookup table will be computed
        let grayThicknessMap =[];

        //Intermediate calculations
        let rgbImage=null;
        let rgbArray=[];

        let grayscaleImage = null;
        let grayscaleArray=[];

        let thicknessArray = [];

        let heightImage = null;
        let heightArray = []

        function docOnLoad() {
            setListeners();
            resumeFromStorageValues();
        }

        function setListeners() {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        loadImage(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            });

            maxThicknessInput.addEventListener('change', onThicknessChange);
            minThicknessInput.addEventListener('change', onThicknessChange);

            grayscaleAlgoSelect.addEventListener('change', onGraySelectChange);
            redGrayValueInput.addEventListener('change', onGrayValueChange);
            greenGrayValueInput.addEventListener('change', onGrayValueChange);
            blueGrayValueInput.addEventListener('change', onGrayValueChange);
            maximizeContrastCheckbox.addEventListener('change', onGrayValueChange);

            materialSelect.addEventListener('change', onMaterialSelectChange);
            redTransmissionInput.addEventListener('change', onMaterialValueChange);
            greenTransmissionInput.addEventListener('change', onMaterialValueChange);
            blueTransmissionInput.addEventListener('change', onMaterialValueChange);

            lightSourceSelect.addEventListener('change', onLightSelectChange);
            redLightInput.addEventListener('change', onLightValueCange);
            greenLightInput.addEventListener('change', onLightValueCange);
            blueLightInput.addEventListener('change', onLightValueCange);

            eyeSensSelect.addEventListener('change', onEyeSensSelectChange);
            redEyeSensInput.addEventListener('change', onEyeSensValueChange);
            greenEyeSensInput.addEventListener('change', onEyeSensValueChange);
            blueEyeSensInput.addEventListener('change', onEyeSensValueChange);
        }

        function onThicknessChange() {
            maxThickness = parseFloat(maxThicknessInput.value);
            minThickness = parseFloat(minThicknessInput.value);
            computeMinMaxTransmission();
            saveStorageValues();
        }

        function onGraySelectChange() {
            let input_disabled = false;
            grayscaleAlgo = grayscaleAlgoSelect.value;
            switch(grayscaleAlgo) {
                case "humaneye":
                    input_disabled = true;
                    redGrayValue = 0.299;
                    greenGrayValue = 0.587;
                    blueGrayValue = 0.114;
                    break;

                case "linear":
                    input_disabled = true;
                    redGrayValue = 1.0;
                    greenGrayValue = 1.0;
                    blueGrayValue = 1.0;
                    break;

                case "custom":
                    input_disabled = false;
                    redGrayValue = c_redGrayValue;
                    greenGrayValue = c_greenGrayValue;
                    blueGrayValue = c_blueGrayValue;
                    break;
            }
            redGrayValueInput.value = redGrayValue;
            greenGrayValueInput.value = greenGrayValue;
            blueGrayValueInput.value = blueGrayValue;
            redGrayValueInput.disabled = input_disabled;
            greenGrayValueInput.disabled = input_disabled;
            blueGrayValueInput.disabled = input_disabled;
            redGrayValueInput.dispatchEvent(new Event('change'));
        }

        function onGrayValueChange() {
            maximizeContrast = maximizeContrastCheckbox.checked;
            redGrayValue = parseFloat(redGrayValueInput.value);
            greenGrayValue = parseFloat(greenGrayValueInput.value);
            blueGrayValue = parseFloat(blueGrayValueInput.value);
            if(grayscaleAlgoSelect.value == "custom") {
                c_redGrayValue = redGrayValue;
                c_greenGrayValue = greenGrayValue;
                c_blueGrayValue = blueGrayValue;
            }

            let totalGrayValue = redGrayValue + greenGrayValue + blueGrayValue;
            i_redGrayValue = redGrayValue/totalGrayValue;
            i_greenGrayValue = greenGrayValue/totalGrayValue;
            i_blueGrayValue = blueGrayValue/totalGrayValue;
            saveStorageValues();
        }

        function onMaterialSelectChange() {
            let input_disabled = false;
            material = materialSelect.value;
            switch(material) {
                case "pla_white":
                    input_disabled = true;
                    redTransmission = 0.901 ;
                    greenTransmission =  0.707;
                    blueTransmission =  0.484;
                    break;

                case "custom":
                    input_disabled = false;
                    redTransmission = c_redTransmission ;
                    greenTransmission = c_greenTransmission;
                    blueTransmission = c_blueTransmission;
                    break;
            }
            redTransmissionInput.value = redTransmission;
            greenTransmissionInput.value = greenTransmission;
            blueTransmissionInput.value = blueTransmission;
            redTransmissionInput.disabled = input_disabled;
            greenTransmissionInput.disabled = input_disabled;
            blueTransmissionInput.disabled = input_disabled;
            redTransmissionInput.dispatchEvent(new Event('change'));
        }

        function onMaterialValueChange() {
            transmissionThickness = parseFloat(transmissionThicknessInput.value);
            redTransmission = parseFloat(redTransmissionInput.value);
            greenTransmission = parseFloat(greenTransmissionInput.value);
            blueTransmission = parseFloat(blueTransmissionInput.value);
            if(materialSelect.value == "custom") {
                c_redTransmission = redTransmission;
                c_greenTransmission = greenTransmission;
                c_blueTransmission = blueTransmission;
            }

            let totalTransmission = redTransmission + greenTransmission + blueTransmission;
            i_redAbsorbance = Math.log(redTransmission/totalTransmission)/transmissionThickness;
            i_greenAbsorbance = Math.log(greenTransmission/totalTransmission)/transmissionThickness;
            i_blueAbsorbance = Math.log(blueTransmission/totalTransmission)/transmissionThickness;
            computeMinMaxTransmission();
            saveStorageValues();
        }

        function onLightSelectChange() {
            let input_disabled = false;
            lightSource = lightSourceSelect.value;
            switch(lightSource) {
                case "sunlight":
                    input_disabled = true;
                    redLight = 300;
                    greenLight = 300;
                    blueLight = 400;
                    break;

                case "7000k":
                    input_disabled = true;
                    redLight = 100;
                    greenLight = 100;
                    blueLight = 100;
                    break;

                case "5700k":
                    input_disabled = true;
                    redLight = 100;
                    greenLight = 100;
                    blueLight = 100;
                    break;

                case "4000k":
                    input_disabled = true;
                    redLight = 100;
                    greenLight = 100;
                    blueLight = 100;
                    break;

                case "2700k":
                    input_disabled = true;
                    redLight = 100;
                    greenLight = 100;
                    blueLight = 100;
                    break;

                case "custom":
                    input_disabled = false;
                    redLight = c_redLight;
                    greenLight = c_greenLight;
                    blueLight = c_blueLight;
                    break;
            }
            redLightInput.value = redLight;
            greenLightInput.value = greenLight;
            blueLightInput.value = blueLight;
            redLightInput.disabled = input_disabled;
            greenLightInput.disabled = input_disabled;
            blueLightInput.disabled = input_disabled;
            redLightInput.dispatchEvent(new Event('change'));
        }

        function onLightValueCange() {
            redLight = parseFloat(redLightInput.value);
            greenLight = parseFloat(greenLightInput.value);
            blueLight = parseFloat(blueLightInput.value);
            if(lightSourceSelect.value == "custom") {
                c_redLight = redLight;
                c_greenLight = greenLight;
                c_blueLight = blueLight;
            }

            let totalLight = redLight + greenLight + blueLight;
            i_redLight = redLight/totalLight;
            i_greenLight = greenLight/totalLight;
            i_blueLight = blueLight/totalLight;
            computeApparentFlux();
            computeMinMaxTransmission();
            saveStorageValues();
        }

        function onEyeSensSelectChange() {
            let input_disabled = false;
            eyeSens = eyeSensSelect.value;
            switch(eyeSens) {
                case "standard":
                    input_disabled = true;
                    redEyeSens = 0.299;
                    greenEyeSens = 0.587;
                    blueEyeSens = 0.114;
                    break;

                case "custom":
                    input_disabled = false;
                    redEyeSens = c_redEyeSens;
                    greenEyeSens = c_greenEyeSens;
                    blueEyeSens = c_blueEyeSens;
                    break;
            }

            redEyeSensInput.value = redEyeSens;
            greenEyeSensInput.value = greenEyeSens;
            blueEyeSensInput.value = blueEyeSens;
            redEyeSensInput.disabled = input_disabled;
            greenEyeSensInput.disabled = input_disabled;
            blueEyeSensInput.disabled = input_disabled;
            redEyeSensInput.dispatchEvent(new Event('change'));
        }

        function onEyeSensValueChange() {
            redEyeSens = parseFloat(redEyeSensInput.value);
            greenEyeSens = parseFloat(greenEyeSensInput.value);
            blueEyeSens = parseFloat(blueEyeSensInput.value);
            if(eyeSensSelect.value == "custom") {
                c_redEyeSens = redEyeSens;
                c_greenEyeSens = greenEyeSens;
                c_blueEyeSens = blueEyeSens;
            }

            let totalEyeSens = redEyeSens + greenEyeSens + blueEyeSens;
            i_redEyeSens = redEyeSens/totalEyeSens;
            i_greenEyeSens = greenEyeSens/totalEyeSens;
            i_blueEyeSens = blueEyeSens/totalEyeSens;
            computeApparentFlux();
            computeMinMaxTransmission();
            saveStorageValues();
        }

        function computeMinMaxTransmission() {
            maxTransmission = beerLambertMultiWavelength(minThickness);
            maxTransmissionInput.value = maxTransmission.toFixed(3);
            minTransmission = beerLambertMultiWavelength(maxThickness);
            minTransmissionInput.value = minTransmission.toFixed(3);
        }

        function computeApparentFlux() {
            let totalApparentFlux = (i_redLight*i_redEyeSens) + 
                                    (i_greenLight*i_greenEyeSens) +
                                    (i_blueLight*i_blueEyeSens);
            i_redApparentFlux = (i_redLight * i_redEyeSens) / totalApparentFlux;
            i_greenApparentFlux = (i_greenLight * i_greenEyeSens) / totalApparentFlux;
            i_blueApparentFlux = (i_blueLight * i_blueEyeSens) / totalApparentFlux;
        }

        function resumeFromStorageValues() {
            maxThickness = localStorage.getItem("maxThickness") || 10;
            maxThicknessInput.value = maxThickness;
            minThickness = localStorage.getItem("minThickness") || 0.6;
            minThicknessInput.value = minThickness;

            maximizeContrast = localStorage.getItem("maximizeContrast") || true;
            maximizeContrastCheckbox.checked = maximizeContrast;
            grayscaleAlgo = localStorage.getItem("grayscaleAlgo") || 'humaneye';
            grayscaleAlgoSelect.value = grayscaleAlgo
            c_redGrayValue = localStorage.getItem("c_redGrayValue") || 0.299;
            c_greenGrayValue = localStorage.getItem("c_greenGrayValue") || 0.587;
            c_blueGrayValue = localStorage.getItem("c_blueGrayValue") || 0.114;

            material = localStorage.getItem("material") || "pla_white";
            materialSelect.value = material;
            transmissionThickness = localStorage.getItem("transmissionThickness") || 2.0;
            transmissionThicknessInput.value = transmissionThickness;
            c_redTransmission = localStorage.getItem("c_redTransmission") || 0.901;
            c_greenTransmission = localStorage.getItem("c_greenTransmission") || 0.707;
            c_blueTransmission = localStorage.getItem("c_blueTransmission") || 0.484;

            lightSource = localStorage.getItem("lightSource") || "sunlight";
            lightSourceSelect.value = lightSource;
            c_redLight = localStorage.getItem("c_redLight") || 300;
            c_greenLight = localStorage.getItem("c_greenLight") || 300;
            c_blueLight = localStorage.getItem("c_blueLight") || 400;

            eyeSens = localStorage.getItem("EyeSens") || "standard";
            eyeSensSelect.value = eyeSens;
            c_redEyeSens = localStorage.getItem("c_redEyeSens") || 0.299;
            c_greenEyeSens = localStorage.getItem("c_greenEyeSens") || 0.587;
            c_blueEyeSens = localStorage.getItem("c_blueEyeSens") || 0.114;

            eyeSensSelect.dispatchEvent(new Event('change'));
            lightSourceSelect.dispatchEvent(new Event('change'));
            materialSelect.dispatchEvent(new Event('change'));
            grayscaleAlgoSelect.dispatchEvent(new Event('change'));
            maxThicknessInput.dispatchEvent(new Event('change'));
        }

        function saveStorageValues() {
            localStorage.setItem("maxThickness", maxThickness);
            localStorage.setItem("minThickness", minThickness);
            localStorage.setItem("maxTransmission", maxTransmission);
            localStorage.setItem("minTransmission", minTransmission);
            localStorage.setItem("maximizeContrast", maximizeContrast);
            localStorage.setItem("grayscaleAlgo", grayscaleAlgo);
            localStorage.setItem("c_redGrayValue", c_redGrayValue);
            localStorage.setItem("c_greenGrayValue", c_greenGrayValue);
            localStorage.setItem("c_blueGrayValue", c_blueGrayValue);
            localStorage.setItem("material", material);
            localStorage.setItem("c_redTransmission", c_redTransmission);
            localStorage.setItem("c_greenTransmission", c_greenTransmission);
            localStorage.setItem("c_blueTransmission", c_blueTransmission);
            localStorage.setItem("lightSource", lightSource);
            localStorage.setItem("c_redLight", c_redLight);
            localStorage.setItem("c_greenLight", c_greenLight);
            localStorage.setItem("c_blueLight", c_blueLight);
            localStorage.setItem("eyeSens", eyeSens);
            localStorage.setItem("c_redEyeSens", c_redEyeSens);
            localStorage.setItem("c_greenEyeSens", c_greenEyeSens);
            localStorage.setItem("c_blueEyeSens", c_blueEyeSens);
        }

        function loadImage(imgSrc) {
            const img = new Image();
            img.src = imgSrc;
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                rgbImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                rgbArray = rgbImage.data;
                origImg.src = canvas.toDataURL();
                rgbDataValid = true;
                grayscaleDataValid = false;
            };
        }

        function computeGrayscale() {
            saveStorageValues();
            makeGrayscaleArray();
            grayscaleImage = new Image();
            grayscaleImage.data = new ImageData(new Uint8ClampedArray(grayscaleArray),
                                                    rgbImage.width, rgbImage.height);
            ctx.putImageData(grayscaleImage.data, 0, 0);
            grayImg.src = canvas.toDataURL();
        }

        //Calculate the heightmap
        function computeHeightmap() {
            saveStorageValues();
            calculateGrayThicknessLookupArray();
            calculateThicknessArray();
            calculateAdjustedGrayscale();
            heightImage = new Image();
            heightImage.data = new ImageData(new Uint8ClampedArray(heightArray),
                                                rgbImage.width, rgbImage.height);
            ctx.putImageData(heightImage.data, 0, 0);
            // Display the resulting image
            outputImg.src = canvas.toDataURL();
        }

        //Calculate the grayscale image
        function makeGrayscaleArray() {
            //Make new image data
            const imgSize = rgbImage.width * rgbImage.height * 4;
            grayscaleArray = new Array(imgSize);

            for (let i = 0; i < rgbArray.length; i += 4) {
                let gray = i_redGrayValue * rgbArray[i] + 
                            i_greenGrayValue * rgbArray[i + 1] + 
                            i_blueGrayValue * rgbArray[i + 2];
                grayscaleArray[i] = grayscaleArray[i + 1] = grayscaleArray[i + 2] = gray;
                grayscaleArray[i+3] = 255.0;
            }

            if(maximizeContrast) {
                let minGray = 255, maxGray = 0;
                //Find min and max gray values in image
                for (let i = 0; i < grayscaleArray.length; i += 4) {
                    const gray = grayscaleArray[i];
                    if (gray < minGray) minGray = gray;
                    if (gray > maxGray) maxGray = gray;
                }

                const scale = 255 / (maxGray - minGray);
                for (let i = 0; i < grayscaleArray.length; i += 4) {
                    const gray = grayscaleArray[i];
                    const scaledGray = (gray - minGray) * scale;
                    grayscaleArray[i] = grayscaleArray[i + 1] = grayscaleArray[i + 2] = scaledGray;
                }
            }
        }


        function calculateGrayThicknessLookupArray() {
            //Produce a lookup array of thicknesses where the index into the array
            //is the gray value (0-255) and the value at that index is the thickness
            grayThicknessMap = [];
            let thickness_guess = 0.5;
            let transmission_per_bit = (maxTransmission - minTransmission)/255;
            for(let gray=0; gray<256; gray += 1) {
                const transmission = (gray*transmission_per_bit)+minTransmission;
                const thickness = findThicknessForTransmission(transmission, thickness_guess)
                thickness_guess = thickness;
                grayThicknessMap.push(thickness)
            }
        }

        function calculateThicknessArray() {
            thicknessArray=[]       
            for (let i = 0; i < grayscaleArray.length; i += 4) {
                const l = grayThicknessMap[Math.floor(grayscaleArray[i])];
                thicknessArray.push(l);
            }
        }

        function calculateAdjustedGrayscale() {
            //Create a new greyscale image where white = minthickness and
            //black = maxthickness
            thicknessMin = 150;
            thicknessMax = 0;
            //Find min and max thickness values
            for (let i = 0; i < thicknessArray.length; i += 1) {
                const thickness = thicknessArray[i];
                if (thickness < thicknessMin) thicknessMin = thickness;
                if (thickness > thicknessMax) thicknessMax = thickness;
            }

            const thicknessRange = thicknessMax - thicknessMin;
            heightArray = [];
            for (let i = 0; i < thicknessArray.length; i += 1) {
                const grayFrac = 1 - ((thicknessArray[i]-thicknessMin)/thicknessRange);
                const gray = Math.floor(255*grayFrac);
                const pixelIndex=4*i;
                heightArray.push(gray);
                heightArray.push(gray);
                heightArray.push(gray);
                heightArray.push(255);
            }
        }

        function beerLambertMultiWavelength(length) {
            //Beer-lambert law: It = I0 * e^-a*l
            //For multiple wavelengths (r,g,b) total light=
            //Itrgb = (Ir*e^-ar*l) + (Ig*e^-ag*l) + (Ib*e^-ab*l)
            console.log(i_redApparentFlux);
            console.log(i_redAbsorbance);
            const Itrgb = (i_redApparentFlux * Math.exp(i_redAbsorbance*length))+
                        (i_greenApparentFlux * Math.exp(i_greenAbsorbance*length))+
                        (i_blueApparentFlux * Math.exp(i_blueAbsorbance*length));
            return Itrgb;
        }

        function derivBeerLambertMultiWavelength(length) {
            //Deriviative of beer-lambert law for multiple absorbance/wavelengths
            const dItrgb = (i_redAbsorbance * i_redApparentFlux * Math.exp(i_redAbsorbance*length))+
                        (i_greenAbsorbance * i_greenApparentFlux * Math.exp(i_greenAbsorbance*length))+
                        (i_blueAbsorbance * i_blueApparentFlux * Math.exp(i_blueAbsorbance*length));
            return dItrgb;
        }

        function findThicknessForTransmission(targetgray, initialThickness, tolerance = 0.0001, maxIterations = 100) {
            //Uses Newton-Raphson formula to find a thickness for a given targetGray value
            let x = initialThickness;
            for (let i = 0; i < maxIterations; i++) {
                const y = beerLambertMultiWavelength(x);
                const error = y - targetgray;
                if (Math.abs(error) < tolerance) {
                    return x;
                }
                const derivative = derivBeerLambertMultiWavelength(x);
                if (derivative === 0) {
                    console.error("Derivative is zero. No solution found.");
                    return null;
                }
                x = x - error / derivative; 
            }
            console.error("Max iterations reached without convergence.");
            return null; // Return null if no solution is found within the iteration limit
        }

    </script>
</body>
</html>
